Update 26 Ayg 2009

* fixed a regression in defn code which disabled the ability to make defn's interactive.
* ADDED MONADS!!!
  * identity monad
  * maybe monad
  * sequence monad
* Monads support clojure-style destructuring bind via domonad expressions.
* no support for with-monad yet.


Update 17 July 2009

* fixed bug in dlet which caused an error with using the let*-like semantics.  dlet is now a recursive macro
* todo: re-implement fn in terms of dlet.  Still will require special handling of the top-level form.

Update 15 July 2009

* fixed bug wherein empty arg-lists would give an error.

Update 9 June 2009
* added support for :or forms for sequence binding types.
* Note: You can't use them at the top-level binder because they would confuse the automatic dispatch of function bodies on arity.  Sorry.

Update 8 June 2009
* added support for :keys in table binder, corrected several small bugs introduced by new parsing code.

Update 7 June 2009
* rewrote binder parsing code so that it is easier to extend and support error checking
* added support for :or forms in table binders.  The form after :or is evaluated at call-time, rather than compile time, and must result in a hash-table with the appropriate keys to provide defaults.

(defn f [a [:: z :z :or (tbl! :z 100)]] (list a z))
(f 10 (tbl! :z 11)) -> (10 11)
(f 10 (tbl!)) -> (10 100)


Update 2 June 2009
* added extensive checking of binder forms at compile time and what are hopefully informative error messages. 
* Todo
  - add support for :or form to the table destructuring

Update 1 June 2009
* defn now expands in terms of the fn macro
* lots more error checking.  Some simple checks for misformed binders, also checks for arity when the function is called.

Update 31 May 2009
* added support for multiple arity defn and fn definitions:

    (defn f 
      ([x] x)
	  ([x y] (* x y)))
    (f 10) ; -> 10
    (f 10 20) ; -> 200

  

Some emacs utilities with clojure-style destructuring bind.

	 (defn demo [a b [c d]] (list a b c d))
	 (demo 1 2 (list 10 11)) -> (1 2 10 11)

The binding also works with hashtables.

	(defn demo [a b [:: c :x d :y]] (list a b c d))
	(let ((a-table (tbl! :x 100 :y 110)))
	  (demo 1 2 a-table)) -> (1 2 100 110)

Most useful in the utils package may be a pair of functions for creating and manipulating hash tables.

	 (tbl! :x 10 :y 11) ; creates a hash table with keys :x, :y and associated values
	 (tbl a-table :x) ; returns the value at key :x

